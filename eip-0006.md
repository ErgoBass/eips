# EIP-0006: Informal Multi-Stage Specification Format

* Author: Robert Kornacki
* Status: Proposed
* Created: 21-Apr-2020
* License: CC0
* Forking: No fork needed 

### Contents
- [Background And Motivation](#background-and-motivation)
- [How Informal Multi-Stage Contract Specs Are Written](#How-Informal-Multi-Stage-Contract-Specs-Are-Written)
- [Alternative Formatting](#Alternative-formatting)
- [Example NFT Auction Contract](#example-nft-auction-contract)
- [Conclusion](#Conclusion)

### Background And Motivation

[Multi-stage contracts](https://link.springer.com/chapter/10.1007/978-3-030-31500-9_16) are a fascinating tool for implementing complex protocols on a UTXO-based system. They allow for great expressiveness and are generally approachable due to the fact that different phases of a protocol are cleanly separated into their own sub-contracts.

With that said, multi-stage contracts are extremely nascent as a model. This means that though they may be simpler when compared to alternatives, complexity is still going to be present when dealing with protocols that require numerous stages. Furthermore, we could benefit from conveying to others how a protocol is supposed to be implemented and/or work without writing a single line of code.

As such it would be quite handy to have a format to informally define specifications for our multi-stage contracts that is understandable, easily traversable, and can be used as a guide for eventually writing both the on-chain and off-chain code.



### How Informal Multi-Stage Contract Specs Are Written

Let's look at the markdown-based schema in it's entirety and drill down how it works below.

```md
# Contract Name
Contract preamble

## ToC
1. [Bootstrap Stage](<#Bootstrap-Stage>)
2. [X Stage](<#X-Stage>)

## Bootstrap Stage
Preamble of how the contract is bootstrapped. 

### List Of Paths
- [Y Path](<#Y-Path>)
 
### Y Path
Preamble

#### Inputs
1. ...
2. ...
3. ...


#### Outputs
1. ...
2. ...
3. ...


#### Leads To
[X Stage](<#X-Stage>)

---

## X Stage
Preamble

### Hard-coded Values
- ...

### Registers
- R4: ...
- R5: ...


### List Of Paths
- [Y Path](<#Y-Path>)
 
### Y Path
Preamble

#### Inputs
1. ...
2. ...
3. ...


#### Outputs
1. ...
2. ...
3. ...


#### Path Conditions
1. ...
2. ...


#### Leads To
`Hyperlinked name of next stage` OR `Exit`

---

```

As you can see above, each contract is made out of a number of **stages**. Each stage is a specific state in which an actor may find themeslves in within the contract. Except for the boostrap stage, we define the hard-coded values and and the registers of the given stage.

Furthermore, from each stage you have one or more **paths**. These are state transitions from the current stage to another (or to itself recursively). Each path specifies the required **inputs boxes**, **output boxes**, and **path conditions**. Path conditions are the logical checks which are encoded within the script which must be met in order to allow for a state transition to occur and thus for said path to be taken.

Finally, each path also **leads to** somewhere else. In other words, the state transition must move the tokens and data held under the current stage to another. Thus we specify the next stage that a path leads to or `Exit`. Exit signifies that this is an **exit path** meaning that the multi-stage contract is finished executing. This means that the locked data/tokens can "exit" the contract and thus be spent into a box that is not locked under any of the scripts/stages of our contract.

In the Bootstrap Stage(s) there are no hard-coded values, registers, or path conditions because the user is not using a box that is currently locked under an existing stage/script, but instead is creating such a box. Depending on the complexity of a protocol, it is possible for a multi-stage contract to have one or more bootstrap stages (bootstrapping different actors into different stages in the protocol).

Clearly writing out the inputs + outputs as well as the path conditions may feel a little verbose, however this is on purpose. One only needs to focus on the required inputs + outputs when writing off-chain code for creating a transaction for a given path. On the flip side, when writing code which will live on-chain (the script), one only needs to pay attention to the path conditions of a given stage.

Every stage, path, and the multi-stage contract itself has room for a preamble/explanation of what is going on in the given section. This allows for the spec writer to add extra comments and/or make clarifications so that it is painfully clear how the contract is supposed to work when sharing with others.

Using markdown we get the benefit of being able to hyperlink the stages in the ToC, the paths for each stage, and where each path leads to. This provides us with a reasonable interface for going through informal specifications and gaining an understanding of how the different stages are inter-linked. With both an eagle's eye view using the ToC as well as with a targeted/sequential view via following path hyperlinks, we have the ability to dig into how the parts and the whole of any given informal specification work.


### Alternative Formatting

If the list format is too crowded for inputs/outputs/conditions, the following format is available as well for more complicated stages which have a lot of registers and/or tokens.

```md
#### Inputs 
##### Input #1
...
##### Input #2
...

#### Outputs
##### Ouput #1
...
##### Ouput #2
...

#### Path Conditions
##### Condition 1
...
##### Condition 2
...

```

This allows one to use lists within each given section, thereby allowing for much more room to go into detail about specifics. This can be useful for scripts which use several registers across several boxes in their path conditions for example.

With all of that said, let's now look at an example informal specification which uses the above scheme/format to define an NFT auction contract.




# Example NFT Auction Contract
This contract allows a user to initiate an on-chain auction for a NFT/singleton token which accepts bids in Ergs. This informal specification is based off of the discussion/original design from [this Ergo Forum thread](https://www.ergoforum.org/t/auctions-on-ergo/122).


## ToC
1. [Bootstrap Stage](<#bootstrap-stage>)
2. [Auction Stage](<#auction-stage>)


## Bootstrap Stage

This stage allows a user to initiate the auction. It requires that they provide their NFT and a box with Erg which represents the starting bid. There are no hard-coded values, registers, or path conditions because this is the bootstrap stage and thus there is no box locked under a stage/script yet.

### List Of Paths
- [Initiate Auction Path](<#Initiate-Auction-Path>)


### Initiate Auction Path

#### Inputs
1. Box which holds the NFT that is to be put up for auction.
2. Box with Ergs equivalent to the starting bid price.


#### Outputs
1. A box locked under the Auction stage/script that holds the NFT and Ergs from the inputs, which also stores the auction holder's public key in register R4.


#### Leads To
[Auction Stage](<#Auction-Stage>)

---


## Auction Stage
In this stage the NFT is held up for auction and anyone who has enough Ergs can place a bid before the auction ends. All new bids must increment by at least 0.5 Erg.

### Hard-coded Values
- Auction holder's public key
- Auction end block height

### Registers
- R4: The current highest bidder's public key

### List Of Paths
- [Bid Path](<#Bid-Path>)
- [Conclude Auction Path](<#Conclude-Auction-Path>)


### Bid Path
This path recurses the box back into the Auction stage with the new Ergs held inside and the current winning bidder in R4 updated.

#### Inputs
1. The auction box.
2. Box(es) owned by the bidder which has enough Ergs to total the previous bid + 0.5 Erg.


#### Outputs
1. A new box locked under the Auction stage again which has the new bidder's public key in R4, the NFT, and the Ergs for the bid.
2. A box owned by the previous bidder which gives them back the Ergs which they bid.


#### Path Conditions
1. The current block height must be less than the auction end block height hard-coded into the script.
2. The first output box must be locked under the Auction script and holds the bidder's public key in R4, the NFT, and Ergs totalling at least 0.5 Erg more than the previous bid.
3. The second output box is owned by the previous bidder and has a total number of Ergs equal to their bid.


#### Leads To
[Auction Stage](<#Auction-Stage>)


### Conclude Auction Path

This path allows for the NFT and the funds to be redeemed to the auction winner and holder respectively once the auction finish height has been reached. If no one bid on the auction then the auction holder still has their public key in register R4, and therefore can redeem both their NFT and their Ergs to themselves.

#### Inputs
1. The auction box.


#### Outputs
1. A box owned by the address stored in R4 which holds the NFT.
2. A box owned by the auction holder which receives all of the Ergs bid.


#### Path Conditions
1. The current block height must be grater than the auction end block height hard-coded into the script.
2. The first output box must hold the NFT and be owned by the pub key stored in R4.
3. The second output box must hold all of the Ergs and be owned by the auction holder.


#### Leads To
Exit

---


### Conclusion

The markdown-based schema outlined in this document provides the writer the feeling of freedom via easily changing whatever they've written as if it were an essay rather than the clunky feeling of writing compiled code (or a formal spec). 
This flexibility is useful when figuring out how to implement a protocol which typically requires making edits often and moving fast as previous ideas become obsolete and/or are found to be broken.

Once an informal specification has been finalized, it can be used as a clear guide for:
1. Writing a formal specification.
2. Implementing the scripts in ErgoScript.
3. Designing the off-chain transaction logic.

As such it is my contention that utilizing this informal specification format is important for the long-term success of contracts and dApps on the Ergo Platform.
