# EIP-0006: Informal Multi-Stage Protocol Specification Format

* Author: Robert Kornacki
* Status: Proposed
* Created: 21-Apr-2020
* License: CC0
* Forking: No fork needed 

### Contents
- [Terminology](#Terminology)
- [Background And Motivation](#background-and-motivation)
- [How Informal Multi-Stage Protocol Specs Are Written](#How-Informal-Multi-Stage-Protocol-Specs-Are-Written)
- [Alternative Formatting](#Alternative-formatting)
- [Example NFT Auction Protocol](#example-nft-auction-protocol)
- [Conclusion](#Conclusion)

### Terminology


##### Script/Contract
The code which locks a given box/UTXO.

##### Multi-Stage Protocol
An on-chain smart-contract based protocol which consists of two or more stages.

##### Stage
A state within a multi-stage protocol that is reachable by users. A stage (omitting bootstrap stages) is strictly defined by its:
1. Contract
2. Values that are to be held in the registers

Within the contract of each stage the following are also defined:
1. Hard-coded values relevant to the given stage
2. Spending paths/path conditions

##### Bootstrap Stage
An initial state within a multi-stage protocol which allows a user to join. It is not defined by a box with a given contract and set of registers, as this is a state where the user is bootstrapping their way into the multi-stage protocol at a particular stage.

##### Hard-coded Values
Values relevant to the contract which are encoded directly within it, rather than in a register. An expiration block height or a user's address are common examples of hard-coded values which will not change as the multi-stage protocol runs.

##### Spending Path
A spending path is an action which a user is allowed to perform from a given stage in order to progress forward in the multi-stage protocol. A single stage may have one or more spending paths, each of which has a set of path conditions.

##### Path Conditions
Path conditions (aka spending conditions), are logical checks which are encoded within a contract which allow/disallow a user from using a given spending path.


### Background And Motivation

[Multi-stage protocols](https://link.springer.com/chapter/10.1007/978-3-030-31500-9_16) are a fascinating tool for implementing complex dApps on a UTXO-based system. They allow for great expressiveness and are generally approachable due to the fact that different phases of a protocol are cleanly separated into their own contracts.

With that said, they are extremely nascent as a model for designing smart contract protocols. This means that though they may be simpler when compared to alternatives, complexity is still going to be present when building protocols that require numerous stages. Furthermore, we could benefit from conveying to others how a given protocol is supposed to be implemented and/or work without writing a single line of code.

As such it would be quite handy to have a format to informally define specifications for our multi-stage smart contract protocols that is understandable, easily traversable, and can be used as a guide for eventually writing both the on-chain and off-chain code.



### How Informal Multi-Stage Protocol Specs Are Written

Let's look at the markdown-based schema in it's entirety and drill down how it works below.

```md
# Multi-Stage Protocol Name
Preamble

## ToC
1. [Bootstrap Stage](<#Bootstrap-Stage>)
2. [X Stage](<#X-Stage>)

## Bootstrap Stage
Preamble of how the protocol is bootstrapped. 

### List Of Paths
- [Y Path](<#Y-Path>)
 
### Y Path
Preamble

#### Inputs
1. ...
2. ...
3. ...


#### Outputs
1. ...
2. ...
3. ...


#### Leads To
[X Stage](<#X-Stage>)

---

## X Stage
Preamble

### Hard-coded Values
- ...

### Registers
- R4: ...
- R5: ...



### List Of Paths
- [Y Path](<#Y-Path>)
 
### Y Path
Preamble

#### Inputs
1. ...
2. ...
3. ...


#### Outputs
1. ...
2. ...
3. ...


#### Path Conditions
1. ...
2. ...


#### Leads To
`Hyperlinked name of next stage` OR `Exit`

---

```

As you can see above, each multi-stage protocol is made out of a number of **stages**. Each stage (except for the bootstrap stage) is a state that is reachable by a user. A stage is comprised of a specific contract which locks up tokens and data together with a set of registers. 

From each stage you have one or more **paths**, which are state transitions from the current stage to another (or to itself recursively). Each path specifies the required **inputs boxes**, **output boxes**, and **path conditions**. Path conditions are the logical checks which are encoded within the contract which must be met in order to allow for a state transition to occur and thus for said path to be taken.

Finally, each path also **leads to** somewhere else. In other words, the state transition must move the tokens and data held under the current stage to another. Thus we specify the next stage that a path leads to or `Exit`. Exit signifies that this is an **exit path** meaning that the multi-stage protocol is finished executing and the locked data/tokens can be used/moved as the user wishes into a new box of their choosing.

In the Bootstrap Stage there are no hard-coded values, registers, or path conditions because the user has no box(es) which are in any of the stages of the protocol. Depending on the complexity of a protocol, it is possible for a multi-stage protocol to have one or more bootstrap stages (bootstrapping different actors into different stages in the protocol).

Clearly writing out the inputs + outputs as well as the path conditions may feel a little verbose, however this is on purpose. One only needs to focus on the required inputs + outputs when writing off-chain code for creating a transaction for a given path. On the flip side, when writing code which will live on-chain (the contracts), one only needs to pay attention to the path conditions of a given stage.

Every stage, path, and the protocol itself has room for a preamble/explanation of what is going on in the given section. This allows for the spec writer to add extra comments and/or make clarifications so that it is painfully clear how the multi-stage protocol is supposed to work when sharing with others.

Using markdown we get the benefit of being able to hyperlink the stages in the ToC, the paths for each stage, and where each path leads to. This provides us with a reasonable interface for going through informal specifications and gaining an understanding of how the different stages are inter-linked. With both an eagle's eye view using the ToC as well as with a targeted/sequential view via following path hyperlinks, we have the ability to dig into how the parts and the whole of any given informal specification work.


### Alternative Formatting

If the list format is too crowded for inputs/outputs/conditions, the following format is available as well for more complicated protocols which have a lot of registers and/or tokens.

```md
#### Inputs 
##### Input #1
...
##### Input #2
...

#### Outputs
##### Ouput #1
...
##### Ouput #2
...

#### Path Conditions
##### Condition 1
...
##### Condition 2
...

```

This allows one to use lists within each given section, thereby allowing for much more room to go into detail about specifics. This can be useful for contracts which use several registers across several boxes in their path conditions for example.

With all of that said, let's now look at an example informal specification which uses the above scheme/format to define an NFT auction protocol.




# Example NFT Auction Protocol
This protocol allows a user to initiate an on-chain auction for a NFT/singleton token which accepts bids in Ergs. This informal specification is based off of the discussion/original design from [this Ergo Forum thread](https://www.ergoforum.org/t/auctions-on-ergo/122).


## ToC
1. [Bootstrap Stage](<#bootstrap-stage>)
2. [Auction Stage](<#auction-stage>)


## Bootstrap Stage

This stage allows a user to initiate the auction. It requires that they provide their NFT and a box with Ergs which represents the starting bid. There are no hard-coded values, registers, or path conditions because this is the bootstrap stage and thus there is no contract yet.

### List Of Paths
- [Initiate Auction Path](<#Initiate-Auction-Path>)


### Initiate Auction Path

#### Inputs
1. Box which holds the NFT that is to be put up for auction.
2. Box with Ergs equivalent to the starting bid price.


#### Outputs
1. A box locked under the Auction contract/stage that holds the NFT and Ergs from the inputs, which also stores the auction holder's public key in register R4.


#### Leads To
[Auction Stage](<#Auction-Stage>)

---


## Auction Stage
In this stage the NFT is held up for auction and anyone who has enough Ergs can place a bid before the auction ends. All new bids must increment by at least 0.5 Erg.

### Hard-coded Values
- Auction holder's public key
- Auction end block height

### Registers
- R4: The current highest bidder's public key


### List Of Paths
- [Bid Path](<#Bid-Path>)
- [Conclude Auction Path](<#Conclude-Auction-Path>)


### Bid Path
This path recurses the box back into the Auction stage with the new Ergs held inside and the current winning bidder in R4 updated.

#### Inputs
1. The auction box.
2. Box(es) owned by the bidder which has enough Ergs to total the previous bid + 0.5 Erg.


#### Outputs
1. A new box locked under the Auction contract again which has the new bidder's public key in R4, the NFT, and the Ergs for the bid.
2. A box owned by the previous bidder which gives them back the Ergs which they bid.


#### Path Conditions
1. The current block height must be less than the auction end block height hard-coded into the contract.
2. The first output box must be locked under the Auction contract and holds the bidder's public key in R4, the NFT, and Ergs totalling at least 0.5 Erg more than the previous bid.
3. The second output box is owned by the previous bidder and has a total number of Ergs equal to their bid.


#### Leads To
[Auction Stage](<#Auction-Stage>)


### Conclude Auction Path

This path allows for the NFT and the funds to be redeemed to the auction winner and holder respectively once the auction finish height has been reached. If no one bid on the auction then the auction holder still has their public key in register R4, and therefore can redeem both their NFT and their Ergs to themselves.

#### Inputs
1. The auction box.


#### Outputs
1. A box owned by the address stored in R4 which holds the NFT.
2. A box owned by the auction holder which receives all of the Ergs bid.


#### Path Conditions
1. The current block height must be grater than the auction end block height hard-coded into the contract.
2. The first output box must hold the NFT and be owned by the pub key stored in R4.
3. The second output box must hold all of the Ergs and be owned by the auction holder.


#### Leads To
Exit

---


### Conclusion

The informal markdown-based schema outlined in this document provides the writer the feeling of freedom via easily changing whatever they've written as if it were an essay rather than the clunky feeling of writing compiled code (or a formal spec). 
This flexibility is useful when figuring out how to implement a protocol which typically requires making edits often and moving fast as previous ideas become obsolete and/or are found to be broken.

Once an informal specification has been finalized, it can be used as a clear guide for:
1. Writing a formal specification.
2. Implementing the contracts in ErgoScript.
3. Designing the off-chain transaction logic.

As such it is my contention that utilizing this informal specification format is important for the long-term success of contracts and dApps on the Ergo Platform.